--!native
--[[
  Licensed under the MIT License (see LICENSE file for full details).
  Copyright (c) 2025 MrY7zz

  LEGAL NOTICE:
  You are REQUIRED to retain this license header under the terms of the MIT License.
  Removing or modifying this notice may violate copyright law.
]]
if not game.IsLoaded then
	game.Loaded:Wait()
end

local game = game
local debug = debug
local debug_info = debug.info

local gameIndex
local gameNewIndex

local getrawmetatableworks = false
local isindexsupported = false

if getrawmetatable then
	local s, r = pcall(getrawmetatable, game)
	if s then  
		if r.__index then
			gameIndex = r.__index
			gameNewIndex = r.__newindex
			getrawmetatableworks = true
		end
	end
end

if not getrawmetatableworks then
	xpcall(function()
		return game[{}]
	end, function()
		gameIndex = debug_info(2, "f")
	end)

	xpcall(function()
		game[{}] = {}
	end, function()
		gameNewIndex = debug_info(2, "f")
	end)
end

local successtest, err = pcall(function()
    return gameIndex(game:GetService("Workspace"), "Parent")
end)

if not successtest then
    if string.find(err:lower(), "instance expected") then
        isindexsupported = false
    else
        isindexsupported = true
    end
        else
    isindexsupported = true
end

local zeropointone = 0.1
local twait = task.wait
local tspawn = task.spawn
local currentfakechar = nil
local vector3zero = Vector3.zero
local getgenv = getgenv or function()
	return _G
end

local NaN = 0/0

local dummypart = Instance.new("Part")

local GetDescendants = dummypart.GetDescendants
local IsA = dummypart.IsA
local Destroy = dummypart.Destroy

local function getsetting(string_, default) --// Finally
	if _G[string_] == nil then
		return default
	else
		return _G[string_]
	end
end

local math_random = math.random
local Vector3_new = Vector3.new

local usedefaultanims = getsetting("Use default animations", false)

local transparency_level = getsetting("Local character transparency level", 1) or getsetting("Fake character transparency level", 1) --// Backwards compatibility

local disablescripts = getsetting("Disable character scripts", true)

local fakecollisions = getsetting("Fake character should collide", true)

local nametoexcludefromtransparency = getsetting("Names to exclude from transparency", {})

local parentrealchartofakechar = getsetting("Parent real character to fake character", false)

local respawncharacter = getsetting("Respawn character", true)

local instantrespawn = getsetting("Instant respawn", false)

local displaymode = getsetting("Client sided display mode", 1)

local LocalPlayer = game:GetService("Players").LocalPlayer

if not LocalPlayer.Character then
	LocalPlayer.CharacterAdded:Wait()
	twait(zeropointone)
	if LocalPlayer.Character:FindFirstChildOfClass("Humanoid").RigType ~= Enum.HumanoidRigType.R6 then
		error("Script is only compatible with R6 type rigs")
		return
	end
end

local function removeAnims(character)
	if character == currentfakechar then
		return
	end
	local humanoid = character:WaitForChild("Humanoid", 5)
	local animator = humanoid:FindFirstChildWhichIsA("Animator")
	if animator then
		Destroy(animator)
	end
	local animateScript = character:FindFirstChild("Animate")
	if animateScript then
		Destroy(animateScript)
	end
	local a = nil
	a = humanoid.DescendantAdded:Connect(function(child)
		if child:IsA("Animator") then
			Destroy(child)
			a:Disconnect()
			a = nil
		end
	end)
end

LocalPlayer.CharacterAdded:Once(removeAnims)

LocalPlayer.Character.Archivable = true
local originalChar = LocalPlayer.Character
local fakeChar = originalChar:Clone()
fakeChar.Name = LocalPlayer.Name .. "_Fake"
local signaldiedbackend = LocalPlayer.ConnectDiedSignalBackend
local signalkill = LocalPlayer.Kill

if respawncharacter then
	if instantrespawn then
		if replicatesignal then
			replicatesignal(signaldiedbackend)
			twait(game.Players.RespawnTime - 0.05)
			replicatesignal(signalkill)
			LocalPlayer.CharacterAdded:Wait()
			fakeChar.Parent = workspace
			currentfakechar = fakeChar
		end
	else
		originalChar:BreakJoints()
		LocalPlayer.CharacterAdded:Wait()
		fakeChar.Parent = workspace
		currentfakechar = fakeChar
	end
end

twait(zeropointone)

local newChar = LocalPlayer.Character
newChar.Archivable = true

if disablescripts then
	tspawn(function()
		for _, obj in ipairs(fakeChar:GetChildren()) do
			if obj:IsA("LocalScript") then
				obj.Enabled = false
			end
		end
	end)
end

twait(0.4)

LocalPlayer.Character = fakeChar
if parentrealchartofakechar then
	newChar.Parent = fakeChar
end

local newcharTorso = newChar:WaitForChild("Torso")
local fakecharTorso = fakeChar:WaitForChild("Torso")
local newcharRoot = newChar:WaitForChild("HumanoidRootPart")
local fakecharRoot = fakeChar:WaitForChild("HumanoidRootPart")

local limbmapping = {
	Neck = fakeChar:WaitForChild("Head"),
	["Left Shoulder"] = fakeChar:WaitForChild("Left Arm"),
	["Right Shoulder"] = fakeChar:WaitForChild("Right Arm"),
	["Left Hip"] = fakeChar:WaitForChild("Left Leg"),
	["Right Hip"] = fakeChar:WaitForChild("Right Leg")
}

local jointmapping = {
	Neck = newcharTorso:WaitForChild("Neck"),
	["Left Shoulder"] = newcharTorso:WaitForChild("Left Shoulder"),
	["Right Shoulder"] = newcharTorso:WaitForChild("Right Shoulder"),
	["Left Hip"] = newcharTorso:WaitForChild("Left Hip"),
	["Right Hip"] = newcharTorso:WaitForChild("Right Hip")
}

local setdesiredangle = jointmapping["Neck"].SetDesiredAngle

local ToObjectSpace = CFrame.new().ToObjectSpace
local ToEulerAnglesXYZ = CFrame.new().ToEulerAnglesXYZ

local function stepReanimate()
	for joint, limb in pairs(limbmapping) do
			local relativecframe = ToObjectSpace(limb.CFrame, fakecharTorso.CFrame)
	local pitch, yaw, _ = ToEulerAnglesXYZ(relativecframe)
	local angle = 0

	if joint == "Neck" then
		angle = -yaw
	elseif joint == "Left Shoulder" or joint == "Left Hip" then
		angle = pitch
	elseif joint == "Right Shoulder" or joint == "Right Hip" then
		angle = -pitch
	end

	local realJoint = jointmapping[joint]
	setdesiredangle(realJoint, angle)
	if isindexsupported then
        gameNewIndex(realJoint, "CurrentAngle", angle)
	    gameNewIndex(realJoint, "DesiredAngle", angle)
    else
        realJoint.CurrentAngle = angle
        realJoint.DesiredAngle = angle
    end
	if fakecharTorso and not flinging then

		newcharRoot.CFrame = fakecharTorso.CFrame + Vector3_new(0, 0, math_random(1, 2) / 326.19)
		newcharRoot.Velocity = vector3zero
		newcharRoot.RotVelocity = vector3zero

	end
	end
end

local function setdestroyheight(height)
	local sucess, result = pcall(function()
		workspace.FallenPartsDestroyHeight = height
	end)
	if not sucess then
	end
end

local currentheight = workspace.FallenPartsDestroyHeight

local function flinginternal(character, time)
	local time = time or 5

	flinging = true
	local start = tick()
	local connection
	connection = game:GetService("RunService").Heartbeat:Connect(function()
		if tick() - start >= time then
			setdestroyheight(currentheight)
			flinging = false
			connection:Disconnect()
			--break
		end
		if character then
			if character:FindFirstChild("HumanoidRootPart") then
				local velocity = character.HumanoidRootPart.Velocity
				local direction = velocity.Magnitude > 1 and velocity.Unit or Vector3_new(0, 0, 0)
				local predictedPosition = (character.PrimaryPart.CFrame or character.HumanoidRootPart.CFrame).Position + direction * math_random(5, 12)

				newcharRoot.CFrame = CFrame.new(predictedPosition)
				newcharRoot.Velocity = Vector3_new(9e7, 9e7 * 10, 9e7)
				newcharRoot.RotVelocity = Vector3_new(9e8, 9e8, 9e8)
			else
				flinging = false
				connection:Disconnect()
				--break
			end
		else
			flinging = false
			connection:Disconnect()
			--break
		end
	end)

end

getgenv().fling = function(character, time, yield)
	setdestroyheight(NaN)
	local yield = yield or false
	if yield then
		flinginternal(character, time)
	else
		tspawn(flinginternal, character, time)
	end
end

local function disableCollisions()
	pcall(function()
		for _, char in ipairs({ newChar }) do
			for _, obj in ipairs(GetDescendants(char)) do
				if IsA(obj, "BasePart") then
					obj.CanCollide = false
					obj.Massless = true
				end
			end
		end
	end)
end

local function disableCollisionsWithFakeChar()
	pcall(function()
		for _, char in ipairs({ newChar, fakeChar }) do
			for _, obj in ipairs(GetDescendants(char)) do
				if IsA(obj, "BasePart") then
					obj.CanCollide = false
					obj.Massless = true
				end
			end
		end
	end)
end

local RunService = game:GetService("RunService")

RunService.Heartbeat:Connect(stepReanimate)

local humanoidnewchar = newChar:WaitForChild("Humanoid")

humanoidnewchar.PlatformStand = true
humanoidnewchar.AutoRotate = false

if fakecollisions then
	RunService.PreSimulation:Connect(disableCollisions)
else
	RunService.PreSimulation:Connect(disableCollisionsWithFakeChar)
end

workspace.CurrentCamera.CameraSubject = fakeChar:WaitForChild("Humanoid")

if displaymode == 1 then
	for _, part in ipairs(fakeChar:GetDescendants()) do
		if part:IsA("BasePart") or part:IsA("Decal") then
			if not nametoexcludefromtransparency[tostring(part)] then
				part.Transparency = transparency_level
			end
		end
	end
elseif displaymode == 2 then
	for _, part in ipairs(newChar:GetDescendants()) do
		if part:IsA("BasePart") or part:IsA("Decal") then
			if not nametoexcludefromtransparency[tostring(part)] then
				part.Transparency = transparency_level
			end
		end
	end
end

finished = true

if usedefaultanims then
	task_spawn(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/somethingsimade/CurrentAngleV2/refs/heads/main/anims"))()
	end)
end
